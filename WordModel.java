/** Soyeon Kim, cs8bwaha
 * 2/25/18
 *
 *File WordModel.java contains program that constructs a WordModel
 *object, and methods to train a given text to generate a word prediction.
 */

import java.util.HashMap;
import java.util.ArrayList;
import java.io.*;
import java.util.Random;
import java.util.Scanner;

/** class WordModel contains a WordModel constructor and methods that 
 * interacts with an instance variable predictionMap, which is a hashmap
 * containing information about prefixes and predictions.
 */
public class WordModel {

    protected HashMap<ArrayList<String>, 
              HashMap<String, Integer>> predictionMap;
    protected HashMap<ArrayList<String>, ArrayList<String>> cache;
    //count how many words will be used to generate prediction
    protected int degree;
    protected Random random;
    //bottom map of predictionMap that contains prediction and its frequency
    protected HashMap<String, Integer> bottomMap;
    //variable to store how many a prediction word has occurred
    protected int WORDS_TIMES;
    //value of cache that contains strings
    protected ArrayList<String> cacheBottom; 

    /**General contructor for WordModel object.
     *
     * @param degree the number of words that will be used to predict next word
     */
    public WordModel (int degree) {

        //instantiate instance variables
        predictionMap = 
            new HashMap<ArrayList<String>, HashMap<String, Integer>>();

        cache = new HashMap<ArrayList<String>, ArrayList<String>>();
        random = new Random();
        this.degree = degree;
    }



    /**Method increases frequency of a prefix and prediction pair by 1
     *
     *@param prefix Arraylist of string words used that generates prediction 
     *word
     *@param prediction a word generated by prefix
     */
    public void incrementPrediction
        (ArrayList<String> prefix, String prediction){
            //if prefix does not exist as a key in predictionMap, put it as a
            //key in predictionMap
            if(!getPredictionMap().containsKey(prefix) ){

                bottomMap = new HashMap<String, Integer>();

                //put prefix as a key in predictionMap, set its value to a new 
                //bottom map
                getPredictionMap().put(prefix,bottomMap);
            }

            //if prefix exist but prediction does not exist, add prediction
            if(getPredictionMap().containsKey(prefix) && 
                    !(getPredictionMap().get(prefix).containsKey(prediction))){

                getPredictionMap().get(prefix).put(prediction,0);
            }

            //increment the count by one
            int freq = getPredictionMap().get(prefix).get(prediction);
            freq++;

            getPredictionMap().get(prefix).put(prediction, freq);

        }



    /**This methods reads the training text word by word and increment
     *frequency of prefix and prediction pairs in hashmap.
     *
     *@param content string containing the training text
     *
     *@return number of words read from the training string 
     */
    public int trainFromText(String content) {

        Scanner myScanner = new Scanner(content);

        ArrayList<String> list = new ArrayList<String>();

        //add each word from the String content to the new ArrayList
        while(myScanner.hasNext()){
            list.add(myScanner.next().toLowerCase());
        }
        for(int i = degree; i < list.size(); i++){

            //create a sublist
            ArrayList<String> prefix = 
                new ArrayList<String>(list.subList(i-degree, i));

            incrementPrediction(prefix, list.get(i));
        }
        return list.size();
    }



    /**This method creates list of words from the bottom level map in which
     * the words are repeated frequency number of times
     *
     *@param prefix list of words used to generate prediction word
     *
     *@return list of words predicted by prefix
     */
    public ArrayList<String> getFlattenedList(ArrayList<String> prefix){

        //if prefix already exists in cache, directly return the value
        if(getCache().containsKey(prefix)){
            return getCache().get(prefix);
        }

        //if it does not exist, add flattened arraylist to cache and return 
        //the list
        if(!getCache().containsKey(prefix)){
            //add prefix and empty arraylist to cache
            cacheBottom = new ArrayList<String>(); 
            getCache().put(prefix, cacheBottom);

            //iterate through the hashmap bottomMap 
            for(String key: getPredictionMap().get(prefix).keySet()){

                WORDS_TIMES = getPredictionMap().get(prefix).get(key);

                for(int i = 0; i < WORDS_TIMES; i++){
                    //add word to the arraylist
                    cacheBottom.add(key);
                }
                getCache().put(prefix, cacheBottom);
            }
        }
        //return the list of words
        return cacheBottom;
    }



    /**This method calls getFlattenedList and randomly return a word from 
     *the list.
     *
     *@param prefix list of words that comes before prediction
     *
     * @return word that model predicts based on prefix
     */
    public String generateNext(ArrayList<String> prefix) {

        ArrayList<String> list = new ArrayList<String>();

        //get Arraylist of words by calling getFlattenedList()
        list = getFlattenedList(prefix);

        //generate random number for arraylist's index
        int indexNumber = getRandom().nextInt(list.size());

        String str = new String(list.get(indexNumber));
        return str;
    }



    /**this method randomly selects a prefix from all prefixes and use
     * the most recent "degree" words to produce a prediction and add 
     * prediction word to the prefix, and repeat this until the string 
     * contains count number of words.
     *
     *@param count number of words in String returning
     *
     *@return a String of "count" words generated
     */
    public String generate(int count) {

        // get all the keys in predictionMap into an Arraylist
        ArrayList<ArrayList<String>> keys = 
            new ArrayList<ArrayList<String>>(getPredictionMap().keySet());

        StringBuilder string = new StringBuilder();

        //generate a random key
        int index = getRandom().nextInt(keys.size());

        ArrayList<String> strArrList = new ArrayList<String>(keys.get(index)); 

        for(int j= getDegree(); j < count; j++){

            ArrayList<String> prefix = 
                new ArrayList<String>(strArrList.subList(j-getDegree(), j));
            String word = generateNext(prefix);

            //add the word to the arraylist
            strArrList.add(word);
        }

        //convert the arraylist to a single string
        for(String str : strArrList){

            string.append(str);
            string.append(" ");
        }
        String str= new String(string.toString());

        return str;
    }


    /** return reference to predictionMap */
    public HashMap
        <ArrayList<String>, HashMap<String, Integer>> getPredictionMap() {
            return this.predictionMap;
        }

    /* return reference to cache */
    public HashMap<ArrayList<String>, ArrayList<String>> getCache(){
        return this.cache;
    }

    /* return a reference to the random object */
    public Random getRandom(){
        return this.random;
    }

    /* return the degree */
    public int getDegree(){
        return this.degree;
    }



    /* provided for debug purposes,
       but really, provided so students can look at how to iterate HashMap */ 
    public void printMap(){

        /* for each key (prefix) in predictionMap, 
           print prefix, print all predictions with counts */
        for(ArrayList<String> prefix: predictionMap.keySet()){
            System.out.println("Prefix: " + prefix + ":");

            HashMap<String, Integer> freqMap = predictionMap.get(prefix);
            /* for each key (prediction) in the subsequen HashMap, 
               print prediction, print count */
            for (String prediction: freqMap.keySet()){
                System.out.printf("\tPrediction: \"%s\"   Count: %d\n", 
                        prediction, freqMap.get(prediction));           
            }
        }       
    }  
}
